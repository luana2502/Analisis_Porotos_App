# -*- coding: utf-8 -*-
"""Untitled17.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Iv6AflrOhKhQj5LUCoK5YSaY3m86v4fO
"""

# app.py

import streamlit as st
import cv2
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from skimage.measure import label, regionprops # Para medir los porotos
import os

# --- 1. Definici√≥n de Constantes y Conversi√≥n de Unidades ---
# Asume que conoces el factor de calibraci√≥n usado en Colab.
# Si el esc√°ner ten√≠a una resoluci√≥n de 600 DPI (dots per inch), el factor puede ser:
# 1 pulgada = 25.4 mm. 800 px = 25.4 mm -> 1 px = 25.4/600 mm ‚âà 0.042333 mm
# Debes usar el valor exacto que usaste en tu cuaderno.
# EJEMPLO: (Debes reemplazar estos valores si tienes los reales)
dpi=800
px_to_mm = 25.4/dpi
px2_to_mm2 = px_to_mm ** 2

# --- 2. Funciones de Procesamiento (Adaptadas de Colab) ---

@st.cache_resource # Cacha la funci√≥n para que no se re-ejecute innecesariamente
def _segmentar_img(img_bgr, azul_bajo=(90, 50, 50), azul_alto=(140, 255, 255)):
    """Segmenta un √∫nico poroto eliminando el fondo azul (adaptado de tu Colab)."""

    # 1. Convertir BGR a HSV
    hsv = cv2.cvtColor(img_bgr, cv2.COLOR_BGR2HSV)

    # 2. Umbralizar el fondo azul
    low = np.array(azul_bajo, dtype=np.uint8)
    high = np.array(azul_alto, dtype=np.uint8)
    mascara_fondo = cv2.inRange(hsv, low, high)

    # 3. Invertir: Porotos en blanco, fondo en negro
    mascara_porotos = cv2.bitwise_not(mascara_fondo)

    # 4. Morfolog√≠a (Cierre y Apertura) para limpieza
    kernel_size = 5
    close_iters = 2
    open_iters = 1
    kernel = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (kernel_size, kernel_size))

    mascara_limpia = cv2.morphologyEx(mascara_porotos, cv2.MORPH_CLOSE, kernel, iterations=close_iters)
    mascara_limpia = cv2.morphologyEx(mascara_limpia, cv2.MORPH_OPEN, kernel, iterations=open_iters)

    return mascara_limpia

@st.cache_resource
def medir_y_visualizar_porotos(img_bgr, mascara_limpia):
    """
    Etiqueta los porotos en la m√°scara y mide sus propiedades.
    Adaptaci√≥n de la l√≥gica que usa 'regionprops' en tu Colab.
    """
    # 1. Etiquetar y obtener propiedades
    etiquetas = label(mascara_limpia)
    regiones = regionprops(etiquetas)

    # 2. Preparar visualizaci√≥n y DataFrame de resultados
    fig, ax = plt.subplots(figsize=(10, 10))
    img_rgb = cv2.cvtColor(img_bgr, cv2.COLOR_BGR2RGB)
    ax.imshow(img_rgb)
    ax.set_title("Porotos detectados y medidos (mm)")
    ax.set_axis_off()

    filas = []

    for idx, region in enumerate(regiones, start=1):
        # Medidas en p√≠xeles (de tu c√≥digo) [cite: 65]
        perimetro_px = region.perimeter
        eje_mayor_px = region.major_axis_length
        eje_menor_px = region.minor_axis_length
        cy_px, cx_px = region.centroid

        # Conversi√≥n a mm (de tu c√≥digo) [cite: 65]
        area_mm2 = region.area * px2_to_mm2
        perimetro_mm = perimetro_px * px_to_mm
        eje_mayor_mm = eje_mayor_px * px_to_mm
        eje_menor_mm = eje_menor_px * px_to_mm

        # 3. Guardar en DataFrame
        filas.append({
            "id_poroto": idx,
            "area_mm2": f"{area_mm2:.2f}",
            "perimetro_mm": f"{perimetro_mm:.2f}",
            "longitud_eje_mayor_mm": f"{eje_mayor_mm:.2f}",
            "ancho_eje_menor_mm": f"{eje_menor_mm:.2f}",
        })

        # 4. Dibujar caja delimitadora y texto [cite: 66]
        minr, minc, maxr, maxc = region.bbox
        ax.add_patch(plt.Rectangle((minc, minr), maxc - minc, maxr - minc,
                                   edgecolor='lime', linewidth=2.5, fill=False))
        texto = (
            f"ID: {idx}\n"
            f"A: {area_mm2:.1f} mm¬≤\n"
            f"L: {eje_mayor_mm:.1f} mm"
        )
        ax.text(minc + 5, minr + 5, texto, color='yellow', fontsize=12,
                fontweight='bold', va='top', ha='left',
                bbox=dict(facecolor=(0, 0, 0, 0.45), edgecolor='none', pad=2.0))

    df_resultados = pd.DataFrame(filas)
    return fig, df_resultados, etiquetas

# --- 3. Interfaz de Streamlit ---

st.set_page_config(layout="wide", page_title="An√°lisis Morfol√≥gico de Porotos (Demo)")
st.title("üå± Herramienta Interactiva de An√°lisis Morfol√≥gico")
st.markdown("""
Esta herramienta demuestra la segmentaci√≥n y medici√≥n de porotos,
adaptada del an√°lisis realizado en Google Colab.
""")

# Cargar la imagen
st.subheader("Paso 1: Cargar Imagen de Porotos")
uploaded_file = st.file_uploader("Sube una imagen (JPG, PNG, TIF) con fondo azul", type=["jpg", "jpeg", "png", "tif", "tiff"])

if uploaded_file is not None:
    # Leer el archivo como bytes y luego como imagen CV2 (necesario para Streamlit)
    file_bytes = np.asarray(bytearray(uploaded_file.read()), dtype=np.uint8)
    img_bgr = cv2.imdecode(file_bytes, 1)

    if img_bgr is None:
        st.error("No se pudo cargar la imagen. Aseg√∫rate de que el formato sea correcto.")
    else:
        st.success(f"Imagen cargada: {uploaded_file.name}")

        # --- Configuraci√≥n de Par√°metros (Interactividad) ---
        with st.sidebar:
            st.header("Ajustes de Segmentaci√≥n")
            st.markdown("Ajusta el rango HSV para el fondo azul, si es necesario.")
            # Widgets de ajuste basados en los par√°metros por defecto de tu Colab [cite: 20]
            h_low = st.slider("H_min", 0, 180, 90)
            s_low = st.slider("S_min", 0, 255, 50)
            v_low = st.slider("V_min", 0, 255, 50)
            h_high = st.slider("H_max", 0, 180, 140)
            s_high = st.slider("S_max", 0, 255, 255)
            v_high = st.slider("V_max", 0, 255, 255)

            azul_bajo = (h_low, s_low, v_low)
            azul_alto = (h_high, s_high, v_high)

        # --- 4. Ejecuci√≥n del An√°lisis ---
        st.subheader("Paso 2: Resultados del An√°lisis")

        # 1. Segmentaci√≥n
        mascara_limpia = _segmentar_img(img_bgr, azul_bajo, azul_alto)

        # 2. Medici√≥n y Visualizaci√≥n
        fig_mediciones, df_resultados, etiquetas = medir_y_visualizar_porotos(img_bgr, mascara_limpia)

        # --- 5. Mostrar Resultados ---
        col1, col2 = st.columns(2)

        with col1:
            st.image(cv2.cvtColor(img_bgr, cv2.COLOR_BGR2RGB), caption="1. Imagen Original", use_column_width=True)
            st.image(mascara_limpia, caption="2. M√°scara Limpia (Segmentaci√≥n)", use_column_width=True, channels="GRAY")

        with col2:
            st.pyplot(fig_mediciones, use_container_width=True)
            st.markdown("### Caracter√≠sticas Morfol√≥gicas (mm)")
            st.dataframe(df_resultados, use_container_width=True)

            # Bot√≥n para descargar los datos
            csv = df_resultados.to_csv(index=False).encode('utf-8')
            st.download_button(
                label="Descargar datos a CSV",
                data=csv,
                file_name=f'caracteristicas_{uploaded_file.name.split(".")[0]}.csv',
                mime='text/csv',
            )

        st.markdown("""
        **NOTA SOBRE EL COLOR:** El an√°lisis de color dominante (K-Means)
        requiere aislar cada poroto en parches de p√≠xeles y ejecutar el clustering,
        lo cual es intensivo. Si lo necesitas, deber√≠as a√±adir esa l√≥gica
        usando las etiquetas (`etiquetas`) para recortar cada poroto y
        aplicar `KMeans` de `scikit-learn`.
        """)